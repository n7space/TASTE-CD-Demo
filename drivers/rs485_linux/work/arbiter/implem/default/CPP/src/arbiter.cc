// C++ body file for function Arbiter
// Generated by TASTE (kazoo/templates/skeletons/cpp-body/function.tmplt)
// You can edit this file, it will not be overwritten

#include "arbiter.h"
#include "arbiter_state.h"

#include <cassert>
#include <cstring>
#include <chrono>
#include <thread>

arbiter_state ctxt_arbiter;

void arbiter_startup(void)
{
}

void arbiter_enqueue_packet
      (const asn1SccDeliveredRequestData *IN_deliverreqseq)
{
   size_t packet_size = IN_deliverreqseq->length;
   uint8_t *data = reinterpret_cast<uint8_t *>(IN_deliverreqseq->message_data);
   size_t new_all_packets_size = ctxt_arbiter.queue_all_packets_size + packet_size;

   printf("\tEnqueue packet_size = %ld, queue_packets_count = %ld, queue_all_packets_size = %ld\n",
         packet_size, ctxt_arbiter.queue_packets_count, ctxt_arbiter.queue_all_packets_size);

   if (new_all_packets_size >= ctxt_arbiter.queue_size ||
       ctxt_arbiter.queue_packets_count + 1 >= ctxt_arbiter.queue_packets_max_count
      ) {
      printf("\tOutput buffer exceeded - dropped\n");
      return;
   }

   memcpy(&ctxt_arbiter.queue_buffer[ctxt_arbiter.queue_all_packets_size], data, packet_size);
   ctxt_arbiter.queue_packets_size[ctxt_arbiter.queue_packets_count] = packet_size;
   ctxt_arbiter.queue_all_packets_size = new_all_packets_size;
   ++ctxt_arbiter.queue_packets_count;
}

void arbiter_send_queued_packets(void)
{
   if (ctxt_arbiter.queue_packets_count > 0) {
      printf("Sending %ld enqueued packets\n", ctxt_arbiter.queue_packets_count);
   }

   size_t current_head = 0;
   for (size_t i = 0; i < ctxt_arbiter.queue_packets_count; ++i) {
      asn1SccDeliveredRequestData data;
      data.private_data = ctxt_arbiter.private_data;
      data.message_data = reinterpret_cast<asn1SccPlatformSpecificPointer>(
      &ctxt_arbiter.queue_buffer[current_head]);
      data.length = ctxt_arbiter.queue_packets_size[i];
      arbiter_RI_Deliver(&data);
      current_head += ctxt_arbiter.queue_packets_size[i];
   }
   ctxt_arbiter.queue_packets_count = 0;
   ctxt_arbiter.queue_all_packets_size = 0;
}

void arbiter_PI_Init
      (const asn1SccInitRequestData *IN_initreqseq)
{
   ctxt_arbiter.queue_packets_count = 0;
   ctxt_arbiter.queue_all_packets_size = 0;
   ctxt_arbiter.is_receiving = false;
   ctxt_arbiter.private_data = IN_initreqseq->private_data;
}

void arbiter_PI_Deliver
      (const asn1SccDeliveredRequestData *IN_deliverreqseq)
{
   if (!ctxt_arbiter.is_receiving) {
      arbiter_RI_Deliver(IN_deliverreqseq);
   } else {
      arbiter_enqueue_packet(IN_deliverreqseq);
   }
}

void arbiter_PI_Receive
      (const asn1SccReceivedRequestData *IN_receivedreqseq)
{
   arbiter_RI_Receive(IN_receivedreqseq);
}

void arbiter_send_token(void)
{
   asn1SccDeliveredRequestData data;
   data.private_data = ctxt_arbiter.private_data;
   data.message_data = reinterpret_cast<asn1SccPlatformSpecificPointer>(
         arbiter_state::open_listening_window_message);
   data.length = sizeof(arbiter_state::open_listening_window_message);
   arbiter_RI_Deliver(&data);
}

void arbiter_open_receiving_window(void)
{
   printf("\tReceiving window\n");
   ctxt_arbiter.is_receiving = true;
   arbiter_send_token();
}

void arbiter_open_sending_window(void)
{
   printf("\tSending window\n");
   ctxt_arbiter.is_receiving = false;
   arbiter_send_queued_packets();
}

void arbiter_PI_Doorman(void)
{
   static uint64_t interval = 0;
   if (interval++ % arbiter_state::listening_interval == 1) {
      arbiter_open_receiving_window();
   } else {
      arbiter_open_sending_window();
   }
}
