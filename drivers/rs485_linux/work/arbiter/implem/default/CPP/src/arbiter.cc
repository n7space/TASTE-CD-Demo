// C++ body file for function Arbiter
// Generated by TASTE (kazoo/templates/skeletons/cpp-body/function.tmplt)
// You can edit this file, it will not be overwritten

#include "arbiter.h"
#include "arbiter_state.h"

#include <cassert>
#include <cstring>
#include <chrono>
#include <thread>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
arbiter_state ctxt_arbiter;

void arbiter_startup(void)
{
   // Write your initialisation code
   // You may call sporadic interfaces and start timers
   // std::cout << "[Arbiter] Startup" << std::endl;
}

void arbiter_enqueue_packet
      (const asn1SccDeliveredRequestData *IN_deliverreqseq)
{
   size_t packet_size = IN_deliverreqseq->length;
   uint8_t *data = reinterpret_cast<uint8_t *>(IN_deliverreqseq->message_data);
   size_t new_all_packets_size = ctxt_arbiter.queue_all_packets_size + packet_size;
   printf("\tEnqueue packet_size = %ld, queue_packets_count = %ld, queue_all_packets_size = %ld\n",
         packet_size, ctxt_arbiter.queue_packets_count, ctxt_arbiter.queue_all_packets_size);
   if (new_all_packets_size >= QUEUE_SIZE || ctxt_arbiter.queue_packets_count + 1 >= QUEUE_PACKETS_MAX_COUNT) {
      printf("\tOutput buffer exceeded - dropped\n");
      return;
   }

   memcpy(&ctxt_arbiter.queue_buffer[ctxt_arbiter.queue_all_packets_size], data, packet_size);
   ctxt_arbiter.queue_packets_size[ctxt_arbiter.queue_packets_count] = packet_size;
   ctxt_arbiter.queue_all_packets_size = new_all_packets_size;
   ++ctxt_arbiter.queue_packets_count;
}

void arbiter_send_queued_packets
      ()
{
   if (ctxt_arbiter.queue_packets_count > 0) {
      printf("Sending %ld enqueued packets\n", ctxt_arbiter.queue_packets_count);
   }

   size_t current_head = 0;
   for (size_t i = 0; i < ctxt_arbiter.queue_packets_count; ++i) {
      asn1SccDeliveredRequestData data;
      data.private_data = ctxt_arbiter.private_data;
      data.message_data = reinterpret_cast<asn1SccPlatformSpecificPointer>(
      &ctxt_arbiter.queue_buffer[current_head]);
      data.length = ctxt_arbiter.queue_packets_size[i];
      arbiter_RI_Deliver(&data);
      current_head += ctxt_arbiter.queue_packets_size[i];
   }
   ctxt_arbiter.queue_packets_count = 0;
   ctxt_arbiter.queue_all_packets_size = 0;
}

void arbiter_PI_Init
      (const asn1SccInitRequestData *IN_initreqseq)
{
   ctxt_arbiter.queue_packets_count = 0;
   ctxt_arbiter.queue_all_packets_size = 0;
   ctxt_arbiter.is_receiving = false;
   ctxt_arbiter.private_data = IN_initreqseq->private_data;
}

void arbiter_PI_Deliver
      (const asn1SccDeliveredRequestData *IN_deliverreqseq)
{
   if (!ctxt_arbiter.is_receiving) {
      arbiter_RI_Deliver(IN_deliverreqseq);
   } else {
      arbiter_enqueue_packet(IN_deliverreqseq);
   }
}

void arbiter_PI_Receive
      (const asn1SccReceivedRequestData *IN_receivedreqseq)
{
   arbiter_RI_Receive(IN_receivedreqseq);
}

void arbiter_PI_Doorman( void )
{
   static uint64_t interval = 0;
   if (interval++ % 2 == 1) {
      printf("\tReceiving window\n");
      ctxt_arbiter.is_receiving = true;

      asn1SccDeliveredRequestData data;
      data.private_data = ctxt_arbiter.private_data;
      data.message_data = reinterpret_cast<asn1SccPlatformSpecificPointer>(
            arbiter_state::open_listening_window_message);
      data.length = sizeof(arbiter_state::open_listening_window_message);
      arbiter_RI_Deliver(&data);
   } else {
      printf("\tSending window\n");
      ctxt_arbiter.is_receiving = false;
      arbiter_send_queued_packets();
   }
}
