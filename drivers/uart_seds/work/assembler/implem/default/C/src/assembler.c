/* Body file for function Assembler
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the .ads file.   !!
*/
#include "assembler.h"

#include <FreeRTOS.h>
#include <semphr.h>

#include <Escaper.h>
#include <Broker.h>

__attribute__((section(".sdramMemorySection")))
static uart_seds_asn1SccUartHwas uart;

__attribute__((section(".sdramMemorySection")))
static uint64_t sentBytes = 0;
__attribute__((section(".sdramMemorySection")))
static uint64_t bytesToSend = 0;

__attribute__((section(".sdramMemorySection")))
static Escaper escaper;
#define ENCODED_PACKET_BUFFER_SIZE 100
__attribute__((section(".sdramMemorySection")))
static uint8_t encodedPacketBuffer[ENCODED_PACKET_BUFFER_SIZE] = {""};
#define DECODED_PACKET_BUFFER_SIZE 100
__attribute__((section(".sdramMemorySection")))
static uint8_t decodedPacketBuffer[DECODED_PACKET_BUFFER_SIZE] = {""};

void assembler_startup(void)
{
}

void assembler_PI_Init
      (const uart_seds_asn1SccInitRequestData *IN_initreqseq)

{
   Escaper_init(&escaper,
                encodedPacketBuffer,
                ENCODED_PACKET_BUFFER_SIZE,
                decodedPacketBuffer,
                DECODED_PACKET_BUFFER_SIZE);

   uart_seds_asn1SccUartHwasConfig config;
   config.mInstance = UartHwas_Instance_uartHwas_Instance_3;
   config.mBaudrate = UartHwas_Baudrate_uartHwas_Baudrate9600;
   assembler_RI_UartHwas_InitUartCmd_Pi(&uart, &config);

   /* We need to call Pi interface to enable Read interrupts. Otherwise
   ** we will not get any byte from the interface. */
   uart_seds_asn1SccUartHwasInterfaceType_ReadByteAsyncCmd_Type readByte;
   readByte.uart = uart;
   assembler_RI_UartHwas_ReadByteAsyncCmd_Pi(&readByte);
}

void assembler_send_single_byte_to_uarthwas()
{
   if(sentBytes < bytesToSend) {
      uart_seds_asn1SccUartHwasInterfaceType_SendByteAsyncCmd_Type sendByteStructure = {
         .uart = uart,
         .byteToSend = (uart_seds_asn1SccByte) encodedPacketBuffer[sentBytes]
      };

      sentBytes++;
      assembler_RI_UartHwas_SendByteAsyncCmd_Pi(&sendByteStructure);
   } else {
      sentBytes = 0;
      bytesToSend = 0;
   }
}

void assembler_PI_Deliver
      (const uart_seds_asn1SccDeliveredRequestData *IN_deliverreqseq)

{
   uint64_t length = (uint64_t) IN_deliverreqseq->length;
   uint8_t *data = IN_deliverreqseq->data;
   size_t index = 0;

   Escaper_start_encoder(&escaper);
   bytesToSend = Escaper_encode_packet(&escaper, data, length, &index);
   assembler_send_single_byte_to_uarthwas();
}

void assembler_PI_UartHwas_ReadByteAsyncCmd_Ri
      (const uart_seds_asn1SccUartHwasInterfaceType_ReadByteAsyncCmd_TypeNotify *IN_inputparam)

{
   Escaper_decode_packet(&escaper, 1, &IN_inputparam->byteToRead, 1, Broker_receive_packet);
}

void assembler_PI_UartHwas_SendByteAsyncCmd_Ri
      (const uart_seds_asn1SccUartHwasInterfaceType_SendByteAsyncCmd_TypeNotify *IN_inputparam)

{
   assembler_send_single_byte_to_uarthwas();
}

void assembler_PI_UartErrorReporting_OverrunError_Ri
      ( void )
{
}
