/* Body file for function Assembler
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the .ads file.   !!
*/
#include "uart_assembler.h"

#include <assert.h>

#include <FreeRTOS.h>
#include <semphr.h>

#include <Escaper.h>

__attribute__((section(".sdramMemorySection")))
static asn1SccUartHwas uart;

__attribute__((section(".sdramMemorySection")))
static uint64_t sentBytes;
__attribute__((section(".sdramMemorySection")))
static uint64_t bytesToSend;

__attribute__((section(".sdramMemorySection")))
static Escaper escaper;
#define ENCODED_PACKET_BUFFER_SIZE 100
__attribute__((section(".sdramMemorySection")))
static uint8_t encodedPacketBuffer[ENCODED_PACKET_BUFFER_SIZE] = {""};
#define DECODED_PACKET_BUFFER_SIZE 100
__attribute__((section(".sdramMemorySection")))
static uint8_t decodedPacketBuffer[DECODED_PACKET_BUFFER_SIZE] = {""};

__attribute__((section(".sdramMemorySection")))
static asn1SccSystemBus bus_id;

void uart_assembler_startup(void)
{
}

asn1SccUartHwas_Instance uart_assembler_convert_conf_asn_devname_to_hwas
      (asn1SccUART_SEDS_Device_T devname)
{
   switch (devname) {
   case asn1SccUART_SEDS_Device_T_uart4:
      return UartHwas_Instance_uart_uartHwas_Instance_4;
   case asn1SccUART_SEDS_Device_T_uart3:
      return UartHwas_Instance_uart_uartHwas_Instance_3;
   case asn1SccUART_SEDS_Device_T_uart2:
      return UartHwas_Instance_uart_uartHwas_Instance_2;
   case asn1SccUART_SEDS_Device_T_uart1:
      return UartHwas_Instance_uart_uartHwas_Instance_1;
   case asn1SccUART_SEDS_Device_T_uart0:
   default:
      return UartHwas_Instance_uart_uartHwas_Instance_0;
   }
}

asn1SccUartHwas_Instance uart_assembler_convert_conf_asn_baudrate_to_hwas
      (asn1SccUART_SEDS_Baudrate_T baudrate)
{
   switch (baudrate) {
   case asn1SccUART_SEDS_Baudrate_T_b115200:
      return UartHwas_Baudrate_uart_uartHwas_Baudrate115200;
   case asn1SccUART_SEDS_Baudrate_T_b9600:
   default:
      return UartHwas_Baudrate_uart_uartHwas_Baudrate9600;
   }
}

void uart_assembler_invoke_broker_receive_packet
      (enum SystemBus bus_id, uint8_t* const data, const size_t data_size)
{
   asn1SccReceivedRequestData request_data;
   request_data.bus_id = bus_id;
   request_data.message_data = (asn1SccPlatformSpecificPointer) data;
   request_data.length = data_size;
   uart_assembler_RI_Receive(&request_data);
}

void uart_assembler_PI_Init
      (const asn1SccInitRequestData *IN_initreqseq)

{
   assert(IN_initreqseq);
   Escaper_init(&escaper,
                encodedPacketBuffer,
                ENCODED_PACKET_BUFFER_SIZE,
                decodedPacketBuffer,
                DECODED_PACKET_BUFFER_SIZE);

   bus_id = IN_initreqseq->bus_id;

   asn1SccUartHwasConfig config;
   asn1SccUART_SEDS_Conf_T *conf = (asn1SccUART_SEDS_Conf_T *) IN_initreqseq->device_configuration;
   config.mInstance = uart_assembler_convert_conf_asn_devname_to_hwas(conf->devname);
   config.mBaudrate = uart_assembler_convert_conf_asn_baudrate_to_hwas(conf->speed);
   uart_assembler_RI_UartHwas_InitUartCmd_Pi(&uart, &config);

   /* We need to call Pi interface to enable Read interrupts. Otherwise
   ** we will not get any byte from the interface. */
   asn1SccUartHwasInterfaceType_ReadByteAsyncCmd_Type readByte;
   readByte.uart = uart;
   uart_assembler_RI_UartHwas_ReadByteAsyncCmd_Pi(&readByte);
}

void uart_assembler_send_single_byte_to_uarthwas()
{
   if(sentBytes < bytesToSend) {
      asn1SccUartHwasInterfaceType_SendByteAsyncCmd_Type sendByteStructure = {
         .uart = uart,
         .byteToSend = (asn1SccByte) encodedPacketBuffer[sentBytes]
      };

      sentBytes++;
      uart_assembler_RI_UartHwas_SendByteAsyncCmd_Pi(&sendByteStructure);
   } else {
      sentBytes = 0;
      bytesToSend = 0;
   }
}

void uart_assembler_PI_Deliver
      (const asn1SccDeliveredRequestData *IN_deliverreqseq)

{
   uint64_t length = (uint64_t) IN_deliverreqseq->length;
   uint8_t *data = IN_deliverreqseq->message_data;
   size_t index = 0;

   Escaper_start_encoder(&escaper);
   sentBytes = 0;
   bytesToSend = Escaper_encode_packet(&escaper, data, length, &index);
   uart_assembler_send_single_byte_to_uarthwas();
}

void uart_assembler_PI_UartHwas_ReadByteAsyncCmd_Ri
      (const asn1SccUartHwasInterfaceType_ReadByteAsyncCmd_TypeNotify *IN_inputparam)

{
   Escaper_decode_packet(&escaper, bus_id, &IN_inputparam->byteToRead, 1, &uart_assembler_invoke_broker_receive_packet);
}

void uart_assembler_PI_UartHwas_SendByteAsyncCmd_Ri
      (const asn1SccUartHwasInterfaceType_SendByteAsyncCmd_TypeNotify *IN_inputparam)

{
   uart_assembler_send_single_byte_to_uarthwas();
}

void uart_assembler_PI_UartErrorReporting_OverrunError_Ri
      ( void )
{
}
