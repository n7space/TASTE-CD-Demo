/* Body file for function ModeManager
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the header file. !!
*/
#include "modemanager.h"
//#include <stdio.h>

static asn1SccSystemMode systemMode;

void acceptTCconfig(asn1SccTC_Config_Data config_request);
void evaluateModeRequestForOff(const asn1SccTC_Mode_Data mode_request);
void evaluateModeRequestForIdle(const asn1SccTC_Mode_Data mode_request);
void evaluateModeRequestForOn(const asn1SccTC_Mode_Data mode_request);

void modemanager_startup(void)
{
    systemMode = SystemMode_off;
}

void modemanager_PI_tc
(const asn1SccTC_Data *IN_tcdata)

{
    switch(systemMode)
    {
    case SystemMode_off:
    {
        if(IN_tcdata->kind == TC_Data_mode_request_PRESENT)
        {
            evaluateModeRequestForOff(IN_tcdata->u.mode_request);
        }
        else if(IN_tcdata->kind == TC_Data_config_request_PRESENT)
        {
            asn1SccTM_Data tmOutput;
            tmOutput.mode_confirmation = Response_error;
            modemanager_RI_tm(&tmOutput);
        }
        break;
    }
    case SystemMode_idle:
    {
        if(IN_tcdata->kind == TC_Data_mode_request_PRESENT)
        {
            evaluateModeRequestForIdle(IN_tcdata->u.mode_request);
        }
        else if(IN_tcdata->kind == TC_Data_config_request_PRESENT)
        {
            acceptTCconfig(IN_tcdata->u.config_request);
        }
        break;
    }
    case SystemMode_on:
    {
        if(IN_tcdata->kind == TC_Data_mode_request_PRESENT)
        {
            evaluateModeRequestForOn(IN_tcdata->u.mode_request);
        }
        else if(IN_tcdata->kind == TC_Data_config_request_PRESENT)
        {
            acceptTCconfig(IN_tcdata->u.config_request);
        }
        break;
    }
    }
}

void acceptTCconfig(asn1SccTC_Config_Data config_request)
{
    asn1SccActuatorConfig_Data actuatorConfigOutput;
    actuatorConfigOutput.target_height = config_request.target_height;
    modemanager_RI_actuatorConfig(&actuatorConfigOutput);

    asn1SccTM_Data tmOutput;
    tmOutput.mode_confirmation = Response_accepted;
    modemanager_RI_tm(&tmOutput);
}

void evaluateModeRequestForOff(const asn1SccTC_Mode_Data mode_request)
{
    switch(mode_request.choosen_mode)
    {
    case SystemMode_off:
    {
        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);
        break;
    }
    case SystemMode_idle:
    {
        asn1SccActuatorControl_Data actuatorControlOutput;
        actuatorControlOutput.state_request = DeviceState_off;
        modemanager_RI_actuatorControl(&actuatorControlOutput);

        asn1SccSensorControl_Data sensorControlOutput;
        sensorControlOutput.state_request = DeviceState_on;
        modemanager_RI_sensorControl(&sensorControlOutput);

        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);

        systemMode = SystemMode_idle;
        break;
    }
    case SystemMode_on:
    {
        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_error;
        modemanager_RI_tm(&tmOutput);
        break;
    }
    }
}

void evaluateModeRequestForIdle(const asn1SccTC_Mode_Data mode_request)
{
    switch(mode_request.choosen_mode)
    {
    case SystemMode_off:
    {
        asn1SccActuatorControl_Data actuatorControlOutput;
        actuatorControlOutput.state_request = DeviceState_off;
        modemanager_RI_actuatorControl(&actuatorControlOutput);

        asn1SccSensorControl_Data sensorControlOutput;
        sensorControlOutput.state_request = DeviceState_off;
        modemanager_RI_sensorControl(&sensorControlOutput);

        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);

        systemMode = SystemMode_off;
        break;
    }
    case SystemMode_idle:
    {
        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);
        break;
    }
    case SystemMode_on:
    {
        asn1SccActuatorControl_Data actuatorControlOutput;
        actuatorControlOutput.state_request = DeviceState_on;
        modemanager_RI_actuatorControl(&actuatorControlOutput);

        asn1SccSensorControl_Data sensorControlOutput;
        sensorControlOutput.state_request = DeviceState_on;
        modemanager_RI_sensorControl(&sensorControlOutput);

        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);

        systemMode = SystemMode_on;
        break;
    }
    }
}

void evaluateModeRequestForOn(const asn1SccTC_Mode_Data mode_request)
{
    switch(mode_request.choosen_mode)
    {
    case SystemMode_off:
    {
        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_error;
        modemanager_RI_tm(&tmOutput);
        break;
    }
    case SystemMode_idle:
    {
        asn1SccActuatorControl_Data actuatorControlOutput;
        actuatorControlOutput.state_request = DeviceState_off;
        modemanager_RI_actuatorControl(&actuatorControlOutput);

        asn1SccSensorControl_Data sensorControlOutput;
        sensorControlOutput.state_request = DeviceState_on;
        modemanager_RI_sensorControl(&sensorControlOutput);

        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);

        systemMode = SystemMode_idle;
        break;
    }
    case SystemMode_on:
    {
        asn1SccTM_Data tmOutput;
        tmOutput.mode_confirmation = Response_accepted;
        modemanager_RI_tm(&tmOutput);
        break;
    }
    }
}


